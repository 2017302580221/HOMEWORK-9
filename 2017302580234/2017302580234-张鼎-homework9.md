**习题**

**P3**

| step | N^{‘}*N*‘ | D(t),p(t) | D(u),p(u) | D(v),p(v) | D(w),p(w) | D(y),p(y) | D(z),p(z) |
| ---- | --------- | --------- | --------- | --------- | --------- | --------- | --------- |
| 0    | x         | ∞         | ∞         | 3,x       | 6,x       | 6,x       | 8,x       |
| 1    | xv        | 7,v       | 6,v       | 3,x       | 6,x       | 6,x       | 8,x       |
| 2    | xvu       | 7,v       | 6,v       | 3,x       | 6,x       | 6,x       | 8,x       |
| 3    | xvuw      | 7,v       | 6,v       | 3,x       | 6,x       | 6,x       | 8,x       |
| 4    | xvuwy     | 7,v       | 6,v       | 3,x       | 6,x       | 6,x       | 8,x       |
| 5    | xvuwyt    | 7,v       | 6,v       | 3,x       | 6,x       | 6,x       | 8,x       |
| 6    | xvuwytz   | 7,v       | 6,v       | 3,x       | 6,x       | 6,x       | 8,x       |

该算法的工作原理为：每次找到离源点（上面例子的源点就是1号顶点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。基本步骤为

- 将所有的顶点分为两部分：已知最短路程的顶点集合P和未知最短路径的顶点集合Q。最开始，已知最短路径的顶点集合P中只有源点一个顶点。我们这里用一个book[ i ]数组来记录哪些点在集合P中。例如对于某个顶点i，如果book[ i ]为1则表示这个顶点在集合P中，如果book[ i ]为0则表示这个顶点在集合Q中。
- 设置源点s到自己的最短路径为0即dis=0。若存在源点有能直接到达的顶点i，则把dis[ i ]设为e[s][ i ]。同时把所有其它（源点不能直接到达的）顶点的最短路径为设为∞。
- 在集合Q的所有顶点中选择一个离源点s最近的顶点u（即dis[u]最小）加入到集合P。并考察所有以点u为起点的边，对每一条边进行松弛操作。例如存在一条从u到v的边，那么可以通过将边u->v添加到尾部来拓展一条从s到v的路径，这条路径的长度是dis[u]+e[u] [v]。如果这个值比目前已知的dis[v]的值要小，我们可以用新值来替代当前dis[v]中的值。
- 重复第3步，如果集合Q为空，算法结束。最终dis数组中的值就是源点到所有顶点的最短路径。

***



**P5**

初始路由选择表

|      | u    | v    | x    | y    | z    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| v    | ∞    | ∞    | ∞    | ∞    | ∞    |
| x    | ∞    | ∞    | ∞    | ∞    | ∞    |
| z    | ∞    | 6    | 2    | ∞    | 0    |

第一次迭代后路由选择表

|      | u    | v    | x    | y    | z    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| v    | 1    | 0    | 3    | ∞    | 6    |
| x    | ∞    | 3    | 0    | 3    | 2    |
| z    | 7    | 5    | 2    | 5    | 0    |

第二次迭代后路由选择表

|      | u    | v    | x    | y    | z    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| v    | 1    | 0    | 3    | 3    | 5    |
| x    | 4    | 3    | 0    | 3    | 2    |
| z    | 6    | 5    | 2    | 5    | 0    |

第三次迭代后路由选择表与第二次迭代的没有差别，完成网络初始化

|      | u    | v    | x    | y    | z    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| v    | 1    | 0    | 3    | 3    | 5    |
| x    | 4    | 3    | 0    | 3    | 2    |
| z    | 6    | 5    | 2    | 5    | 0    |

**P6**

在每次迭代时，节点与其邻居交换距离表。因此，如果该节点是节点A，而邻居是节点B，则B的所有邻居在一次迭代后将知道一到两个跳到A的最短代价路径。而d是网络中任何两个节点之间最长的无环路路径的长度。经过d-1迭代后，所有节点都将知道d或更少跳到所有其他节点的最短路径代价。由于任何大于d跳的路径都会有循环，该算法最多会在d-1迭代中收敛。

